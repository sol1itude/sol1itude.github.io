<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[收集到的正则表达式]]></title>
      <url>/2019/01/16/regularExpression/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正则表达式在日常开发中经常用到，但是每次都记不住，所以收集了一些常见的正则表达式。</p>
<h1 id="一-校验数字"><a href="#一-校验数字" class="headerlink" title="一.校验数字"></a>一.校验数字</h1><ol>
<li>数字：<code>^[0-9]*$</code></li>
<li>n位的数字：<code>^\d{n}$</code></li>
<li>至少n位的数字：<code>^\d{n,}$</code></li>
<li>m-n位的数字：<code>^\d{m,n}$</code></li>
<li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li>
<li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]{1,2})?$</code></li>
<li>带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d{1,2})?$</code></li>
<li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li>
<li>有两位小数的正实数：<code>^[0-9]+(.[0-9]{2})?$</code></li>
<li>有1~3位小数的正实数：<code>^[0-9]+(.[0-9]{1,3})?$</code></li>
<li>非零的正整数：<code>^[1-9]\d*$</code></li>
<li>非零的负整数：<code>^\-[1-9][]0-9&quot;*$</code></li>
<li>非负整数：<code>^\d+$</code></li>
<li>非正整数：<code>^-[1-9]\d*|0$</code></li>
<li>非负浮点数：<code>^\d+(\.\d+)?$</code></li>
<li>非正浮点数：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code></li>
<li>正浮点数：<code>^[1-9]d.d|0.d[1-9]d$</code></li>
<li>负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code></li>
<li>浮点数：<code>^(-?\d+)(\.\d+)?$</code></li>
</ol>
<h1 id="二-校验字符"><a href="#二-校验字符" class="headerlink" title="二.校验字符"></a>二.校验字符</h1><ol>
<li>汉字：<code>^[\u4e00-\u9fa5]{0,}$</code></li>
<li>英文和数字：<code>^[A-Za-z0-9]+$</code></li>
<li>长度为3-20的所有字符：<code>^.{3,20}$</code></li>
<li>由26个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li>
<li>由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li>
<li>由26个小写英文字母组成的字符串：<code>^[a-z]+$</code></li>
<li>由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li>
<li>由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$</code></li>
<li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li>
<li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code></li>
<li>可以输入含有<code>^%&amp;&#39;,;=?$\&quot;</code>等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code></li>
<li>禁止输入含有~的字符：<code>[^~\x22]+</code></li>
</ol>
<h1 id="三-特殊需求表达式"><a href="#三-特殊需求表达式" class="headerlink" title="三.特殊需求表达式"></a>三.特殊需求表达式</h1><ol>
<li>Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li>
<li>手机号码：<code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</code>(国内 13、15、18开头的手机号正则表达式,可根据目前国内收集号扩展前两位开头号码）</li>
<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<code>^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$</code></li>
<li>国内电话号码(0511-4405222、021-87888822)：<code>\d{3}-\d{8}|\d{4}-\d{7}</code></li>
<li>身份证号(15位）：<code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$</code></li>
<li>身份证号码(18位)：<code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$</code><br>7.帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code></li>
<li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w{5,17}$</code></li>
<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-16之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,16}$</code></li>
<li>日期格式：<code>^\d{4}-\d{1,2}-\d{1,2}</code></li>
<li>一年的12个月(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code></li>
<li>一个月的31天(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>
<li>xml文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li>
<li>中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code></li>
<li>双字节字符：<code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li>
<li>空白行的正则表达式：<code>\n\s*\r</code> (可以用来删除空白行)</li>
<li>首尾空白字符的正则表达式：<code>^\s*|\s*$或(^\s*)|(\s*$)</code> (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>
<li>腾讯QQ号：<code>[1-9][0-9]{4,11}</code> (腾讯QQ号从10000开始)</li>
<li>中国邮政编码：<code>[1-9]\d{5}(?!\d)</code> (中国邮政编码为6位数字)</li>
<li>IP-v4地址：<code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code> (提取IP地址时有用)</li>
<li>校验IP-v6地址:<code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></li>
<li>子网掩码：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>
<li>校验日期:<code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code>(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。)</li>
<li>抽取注释：<code>&lt;!--(.*?)--&gt;</code></li>
<li>查找CSS属性:<code>^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}</code></li>
<li>提取页面超链接:<code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></li>
<li>提取网页图片:<code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]{0,1}([^\\&quot;\\&#39;\\ &gt;]*)</code></li>
<li>提取网页颜色代码:<code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code><br>文件扩展名效验:<code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</code></li>
<li>判断IE版本：<code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6原生Class知识]]></title>
      <url>/2018/12/21/ES6-class/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>js的原生Class直到ES6才实现，而Class已经在其他语言中实现了几十年，现在我们研究一下原生Class。</p>
<p>本文大量参考阮一峰老师的ES6手册。</p>
<h1 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h1><p>IE方面，由于国内需要支持到IE8，所以支持Class就别想了。<br>移动方面，包括微信浏览器、QQ浏览器、其他主流浏览器，都支持Class，所以移动端可以放心用。</p>
<h1 id="ES5之前定义构造函数的常见方法"><a href="#ES5之前定义构造函数的常见方法" class="headerlink" title="ES5之前定义构造函数的常见方法"></a>ES5之前定义构造函数的常见方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先定义一个函数，强行叫它构造函数，大写的P也不是必须的，只是约定俗成</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x; <span class="comment">// 构造函数的属性都定义在函数内部</span></div><div class="line">  <span class="keyword">this</span>.y = y; <span class="comment">// this指向实例对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 构造函数的方法都定义在构造函数的原型上</span></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// new 一个对象，就OK了</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<h1 id="ES6定义类的常见方法"><a href="#ES6定义类的常见方法" class="headerlink" title="ES6定义类的常见方法"></a>ES6定义类的常见方法</h1><p>由于要兼容过去的构造函数写法，所以ES6的类其实就是语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的class改写，就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123; <span class="comment">// 定义构造方法</span></div><div class="line">    <span class="keyword">this</span>.x = x; <span class="comment">// this指向实例对象</span></div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123; <span class="comment">// 定义一个方法，注意这里没有function关键字</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>; <span class="comment">// this指向实例对象</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="class就是function的另一种写法，本质还是function"><a href="#class就是function的另一种写法，本质还是function" class="headerlink" title="class就是function的另一种写法，本质还是function"></a>class就是function的另一种写法，本质还是function</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function" 类的数据类型就是函数</span></div><div class="line">Point === Point.prototype.constructor <span class="comment">// true 类本身就指向构造函数</span></div></pre></td></tr></table></figure>
<h1 id="类里面能定义什么，不能定义什么？"><a href="#类里面能定义什么，不能定义什么？" class="headerlink" title="类里面能定义什么，不能定义什么？"></a>类里面能定义什么，不能定义什么？</h1><p>由于class只是构造函数的语法糖，所以class内部能定义什么有很多限制，截止2018年上半年，规定如下：<br>能定义：</p>
<p>构造方法<br>若干个实例方法<br>静态方法（就是类本身的方法）</p>
<p>有限定条件的定义：<br>实例属性：不能在构造方法外部定义实例属性，只能在构造方法里定义实例属性。<br>绝对不能定义：<br>不能定义静态属性（就是类本身的属性），只能在class外部定义<br>所以，实例属性必须在<code>constructor(){}</code>里面；静态属性必须在class的外面。<br>这些名词的具体解释见下文。</p>
<h1 id="如何使用类"><a href="#如何使用类" class="headerlink" title="如何使用类"></a>如何使用类</h1><p>必须用new，不用new会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</div><div class="line"><span class="built_in">console</span>.log(a.toString()); <span class="comment">// 30</span></div></pre></td></tr></table></figure></p>
<h1 id="class也有prototype"><a href="#class也有prototype" class="headerlink" title="class也有prototype"></a>class也有prototype</h1><p>class的所有方法（比如上面的toString()方法），都定义在prototype上面，这跟构造函数其实是一致的，只不过构造函数是显式的写出来，class是隐式定义。</p>
<p>在类的实例上面调用方法，其实还是调用原型上的方法。跟构造函数情况一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div><div class="line"></div><div class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h1 id="给类增加新动态方法"><a href="#给类增加新动态方法" class="headerlink" title="给类增加新动态方法"></a>给类增加新动态方法</h1><p><code>Object.assign</code>方法可以很方便地一次向类添加多个动态方法。</p>
<p>由于类的动态方法都定义在prototype对象上面，所以类的新动态方法添加在prototype对象上面就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</div><div class="line">  <span class="comment">// 这两个就是给Point新增的动态方法</span></div><div class="line">  toString()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;, <span class="comment">// 别忘了这里的逗号</span></div><div class="line">  toValue()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="类里的方法名可以采用表达式"><a href="#类里的方法名可以采用表达式" class="headerlink" title="类里的方法名可以采用表达式"></a>类里的方法名可以采用表达式</h1><p>class里的方法名可以使用计算值，这是构造函数做不到的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="string">'toString'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  [a]() &#123; <span class="comment">// 把表达式用[]包起来就可以了</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</div><div class="line"><span class="built_in">console</span>.log(b.toString()); <span class="comment">// 30</span></div></pre></td></tr></table></figure>
<h1 id="注意严格模式"><a href="#注意严格模式" class="headerlink" title="注意严格模式"></a>注意严格模式</h1><p>class内部是默认使用严格模式的，所以，最好你就从今天开始养成js代码全局都使用严格模式的习惯，只有好处没有坏处。</p>
<h1 id="class默认自带constructor方法"><a href="#class默认自带constructor方法" class="headerlink" title="class默认自带constructor方法"></a>class默认自带constructor方法</h1><p>constructor方法是类的默认方法，它的作用是：通过new命令生成对象实例时，自动调用该方法。通常类的动态属性都在constructor方法中初始化。</p>
<p>如果没有显式定义constructor方法，则class会默认创建一个空的constructor方法。</p>
<h1 id="class的表达式写法"><a href="#class的表达式写法" class="headerlink" title="class的表达式写法"></a>class的表达式写法</h1><p>跟函数一样，class也可以用表达式写法，下面栗子中，当前作用域下，这个类叫<code>PointClass</code>，但是类的内部，这个类叫<code>Point</code>。</p>
<p>表达式写法中，<code>Point</code>可以省略，跟函数一样。只要类的内部不需要用到<code>Point</code>，就可以省略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> PointClass = <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    Point.x = x;</div><div class="line">    Point.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> Point.x + Point.y;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> PointClass(<span class="number">10</span>, <span class="number">20</span>);</div><div class="line"><span class="built_in">console</span>.log(a.toString()); <span class="comment">// 30</span></div></pre></td></tr></table></figure>
<h1 id="类的声明，不存在变量提升"><a href="#类的声明，不存在变量提升" class="headerlink" title="类的声明，不存在变量提升"></a>类的声明，不存在变量提升</h1><p>我们知道function是有变量提升特性的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>); <span class="comment">// 会被执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而class是没有变量提升特性的。记住这一点。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<h1 id="私有方法、私有属性"><a href="#私有方法、私有属性" class="headerlink" title="私有方法、私有属性"></a>私有方法、私有属性</h1><p>ES6依然没有实现其他语言早已实现的私有方法和私有属性。只能变通实现：</p>
<p>有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。具体需要先了解Symbol，本文略过。</p>
<h1 id="class也有name属性"><a href="#class也有name属性" class="headerlink" title="class也有name属性"></a>class也有name属性</h1><p>name属性是class默认自带属性，它就是返回class的名字，就是跟在class后面的那个类名。</p>
<h1 id="class的取值函数-get-和存值函数-set"><a href="#class的取值函数-get-和存值函数-set" class="headerlink" title="class的取值函数(get)和存值函数(set)"></a>class的取值函数(get)和存值函数(set)</h1><p>在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br>为什么会有这种函数呢？看个栗子。我设一个班作为一个类，这个class有一个人数属性，下面例子中，我new的时候设定初始人数是60人。然后，某时间，班里转入新生30人，我想知道现在多少人？然后过了一阵，又转入20人，我想知道现在多少人，怎么写代码？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassroom</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(number) &#123;</div><div class="line">    <span class="keyword">this</span>.number = number;</div><div class="line">  &#125;</div><div class="line">  get newnumber() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.number;</div><div class="line">  &#125;</div><div class="line">  set newnumber(value) &#123;</div><div class="line">    <span class="keyword">this</span>.number += value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> classroom = <span class="keyword">new</span> MyClassroom(<span class="number">60</span>);</div><div class="line">classroom.newnumber = <span class="number">30</span>;</div><div class="line"><span class="built_in">console</span>.log(classroom.newnumber); <span class="comment">// 90</span></div><div class="line">classroom.newnumber = <span class="number">20</span>;</div><div class="line"><span class="built_in">console</span>.log(classroom.newnumber); <span class="comment">// 110</span></div></pre></td></tr></table></figure>
<p>说白了，get和set关键字，一个负责取值，一个负责存值，如果不这样做，我还能怎么写呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassroom</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(number) &#123;</div><div class="line">    <span class="keyword">this</span>.number = number;</div><div class="line">  &#125;</div><div class="line">  getnewnumber() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.number;</div><div class="line">  &#125;</div><div class="line">  setnewnumber(value) &#123;</div><div class="line">    <span class="keyword">this</span>.number += value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> classroom = <span class="keyword">new</span> MyClassroom(<span class="number">60</span>);</div><div class="line">classroom.setnewnumber(<span class="number">30</span>);</div><div class="line"><span class="built_in">console</span>.log(classroom.getnewnumber()); <span class="comment">// 90</span></div><div class="line">classroom.setnewnumber(<span class="number">20</span>);</div><div class="line"><span class="built_in">console</span>.log(classroom.getnewnumber()); <span class="comment">// 110</span></div></pre></td></tr></table></figure>
<p>这样我不用get和set关键字，而是定义了2个方法，也达到了同样的目的。</p>
<p>所以get和set关键字的优势是什么？</p>
<ol>
<li>简练。如果不用get、set关键字，那么就需要写2个方法名，这样显然不够简练。原本早期阶段编程语言种确实没有get、set概念，那时候程序员们的确经常用getnewnumber和setnewnumber这种方法来定义方法，后来语言的维护者看到既然大家都喜欢这么写，就干脆提出了get和set两个关键字，这样就更精炼了。</li>
<li>直观。 <code>classroom.newnumber = 30</code>是一种更直观的赋值写法，比<code>classroom.setnewnumber(30)</code>这种传参的写法要直观的多。</li>
<li>处理流程分离。get要做的事情跟set要做的事情完全不用。</li>
<li>最重要的一点：安全。虽然ES6还没有实现私有属性和方法，但是其他语言早就实现了，既然私有，意味着不能直接写入和读取，那么怎么办呢？就用get和set作为对外窗口，来统一接收数据和发出数据。当某个属性只允许写，那就只设set没有get，只允许读，就只设get没有set。</li>
<li>操作拦截，其实也是为了安全。如果让你随意修改属性，比如班级人数，没有set的话，你修改number属性就直接修改了人数，怎么可以让你这么轻松的修改呢？因为你如果修改成一个很扯淡的人数呢？或者你不小心把布尔值当数值传进去又该咋办？现在，有set函数，于是所有的类型判断、范围判断、有效性判断，都可以加到里面，全OK的情况下，最终才允许你修改成功。</li>
</ol>
<h1 id="class的Generator方法"><a href="#class的Generator方法" class="headerlink" title="class的Generator方法"></a>class的Generator方法</h1><p>这个Generator词，跟ES6引入的Generator函数的Generator是一个意思。<br>如果class的某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。class结合Generator比较复杂，外部需要<code>for (... of ...) {}</code>来处理实例，如果真的需要的时候，可以再去查专门的资料，这里不多说。</p>
<h1 id="class内部无法定义自身静态属性，只能在外部定义"><a href="#class内部无法定义自身静态属性，只能在外部定义" class="headerlink" title="class内部无法定义自身静态属性，只能在外部定义"></a>class内部无法定义自身静态属性，只能在外部定义</h1><p>需要注意，class内部的this关键字，指向的是实例，并不是类本身。</p>
<p>在class的内部定义静态属性是非法的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">  a: <span class="number">1</span> <span class="comment">// Uncaught SyntaxError: Unexpected token :</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，定义类自身的静态属性， 只能是在外部定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">&#125;</div><div class="line">MyClass.a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(MyClass.a); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h1 id="class可以定义实例属性但必须定义在构造方法里"><a href="#class可以定义实例属性但必须定义在构造方法里" class="headerlink" title="class可以定义实例属性但必须定义在构造方法里"></a>class可以定义实例属性但必须定义在构造方法里</h1><p>目前ES6的规定就是如此，因为class毕竟只是语法糖。</p>
<p>栗子从略，可参看本文任意构造方法。</p>
<h1 id="class可以定义类自身方法（即静态方法）"><a href="#class可以定义类自身方法（即静态方法）" class="headerlink" title="class可以定义类自身方法（即静态方法）"></a>class可以定义类自身方法（即静态方法）</h1><p>类自身的方法，叫做静态方法，做法是在class的一个方法前，加上static关键字。静态方法不会被实例继承，而是直接通过类来调用。</p>
<p>一定要区分class的方法和实例的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassroom</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(number) &#123;</div><div class="line">    <span class="keyword">this</span>.number = <span class="number">60</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> get1() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.number; 静态方法包含的<span class="keyword">this</span>关键字，这个<span class="keyword">this</span>指的是类，而不是实例</div><div class="line">  &#125;</div><div class="line">   <span class="keyword">static</span> get2() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">80</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(MyClassroom.get1()); <span class="comment">// undefined</span></div><div class="line">MyClassroom.number = <span class="number">60</span>;</div><div class="line"><span class="built_in">console</span>.log(MyClassroom.get1()); <span class="comment">// 60</span></div><div class="line"><span class="built_in">console</span>.log(MyClassroom.get2()); <span class="comment">// 80</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> classroom = <span class="keyword">new</span> MyClassroom();</div><div class="line"><span class="built_in">console</span>.log(classroom.get1()); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>静态方法可以与非静态方法重名。</p>
<p>虽然实例无法继承静态方法，但是类的子类可以继承静态方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.classMethod() <span class="comment">// 'hello' 父类Foo有一个静态方法，子类Bar可以调用这个方法。</span></div></pre></td></tr></table></figure>
<p>静态方法也是可以从super对象上调用。具体参考下文关于继承的知识。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.classMethod() <span class="comment">// "hello, too"</span></div></pre></td></tr></table></figure>
<h1 id="new-target用于实现只允许继承，不允许调用的class"><a href="#new-target用于实现只允许继承，不允许调用的class" class="headerlink" title="new.target用于实现只允许继承，不允许调用的class"></a>new.target用于实现只允许继承，不允许调用的class</h1><p><code>new.target</code>必须写在构造方法里面，它指向类本身。具体指向哪个类，有下面说道：</p>
<p>类没有被继承的话，<code>new.target</code>就指向类自身。<br>类被继承的话，<code>new.target</code>指向子类。</p>
<p><code>new.target</code>的用途主要是确定new的对象到底是以哪个类为范本。实践中，基类是不允许被实例化的，靠这个<code>new.target</code>就可以实现基类禁止被实例化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用 new 命令生成实例'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>); <span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>);  <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue开发遇到的问题]]></title>
      <url>/2018/11/29/vue%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[在vue使用rem实现移动端自适配]]></title>
      <url>/2018/08/31/%E5%9C%A8vue%E4%BD%BF%E7%94%A8rem%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>使用vue.js搭建一个移动端项目，怎样做到自适应呢？当然选择rem布局是比较方便快捷的。之前项目中是使用的淘宝的flexible方案，在vue中也可以继续使用这种方法。</p>
<h1 id="1-下载安装lib-flexible"><a href="#1-下载安装lib-flexible" class="headerlink" title="1.下载安装lib-flexible"></a>1.下载安装lib-flexible</h1><p>如果使用的是vue-cli+webpack构建的项目，可以直接使用npm来安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i lib-flexible --save</div></pre></td></tr></table></figure></p>
<h1 id="2-引入lib-flexible"><a href="#2-引入lib-flexible" class="headerlink" title="2.引入lib-flexible"></a>2.引入lib-flexible</h1><p>在main.js中引入lib-flexible<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &apos;lib-flexible/flexible&apos;</div></pre></td></tr></table></figure></p>
<h1 id="3-设置meta标签"><a href="#3-设置meta标签" class="headerlink" title="3.设置meta标签"></a>3.设置meta标签</h1><p>在项目根目录的index.html 头部加入手机端适配的meta的代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="4-安装px2rem-loader"><a href="#4-安装px2rem-loader" class="headerlink" title="4.安装px2rem-loader"></a>4.安装px2rem-loader</h1><p>在实际的开发中，使用flexible插件时 会自动把px转换成rem单位。在vue-cli中安装过lib-flexible之后 ，将px转换成rem，我们将使用px2rem这个工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install px2rem-loader</div></pre></td></tr></table></figure></p>
<h1 id="5-配置px2rem-loader"><a href="#5-配置px2rem-loader" class="headerlink" title="5.配置px2rem-loader"></a>5.配置px2rem-loader</h1><p>在vue-cli生成的webpack 配置中，vue-loader 的options和其他样式文件loader 最终都是由build/untils.js里的一个方法生成的。所以我们打开build/untils.js文件找到cssLoader，在cssLoader后面添加px2remLoader，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> cssLoader = &#123;</div><div class="line">    <span class="attr">loader</span>: <span class="string">'css-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">      <span class="attr">minimize</span>: process.env.NODE_ENV === <span class="string">'production'</span>,</div><div class="line">      <span class="attr">sourceMap</span>: options.sourceMap</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="keyword">const</span> px2remLoader = &#123;</div><div class="line">    <span class="attr">loader</span>: <span class="string">'px2rem-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">remUnit</span>: <span class="number">75</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后找到generateLoaders 方法，在方法里面的loaders数组中添加刚才写的px2remLoader，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateLoaders</span> (<span class="params">loader, loaderOptions</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> loaders = [cssLoader,px2remLoader, postcssLoader]</div><div class="line">    <span class="keyword">if</span> (loader) &#123;</div><div class="line">      loaders.push(&#123;</div><div class="line">        <span class="attr">loader</span>: loader + <span class="string">'-loader'</span>,</div><div class="line">        <span class="attr">options</span>: <span class="built_in">Object</span>.assign(&#123;&#125;, loaderOptions, &#123;</div><div class="line">          <span class="attr">sourceMap</span>: options.sourceMap</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="6-重新运行项目就可以使用了"><a href="#6-重新运行项目就可以使用了" class="headerlink" title="6.重新运行项目就可以使用了"></a>6.重新运行项目就可以使用了</h1><p>直接在项目里写px页面就会编译成rem；这样直接就可以按设计图的尺寸写布局了，如果某个元素不想使用rem，直接在后面写/<em>no</em>/就可以，如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;<span class="comment">/*no*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mpvue使用总结]]></title>
      <url>/2018/06/06/mpvue%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近在学习vue，遇到了一些问题，在这里记录一下。</p>
<h2 id="vue使用路由后刷新页面回到首页"><a href="#vue使用路由后刷新页面回到首页" class="headerlink" title="vue使用路由后刷新页面回到首页"></a>vue使用路由后刷新页面回到首页</h2><blockquote>
<p>项目需要在页面刷新后回到首页，使用的是这个方法。这个this.$router.push(“/“)里面的”/“可以换为你的任何页面，如”/home”,”/company”。</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[工作中遇到的一些问题]]></title>
      <url>/2018/03/06/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="1-记录工作中遇到的一些问题"><a href="#1-记录工作中遇到的一些问题" class="headerlink" title="1.记录工作中遇到的一些问题"></a>1.记录工作中遇到的一些问题</h2><blockquote>
<p>iOS Safari 中click点击事件失效的解决办法,当使用委托给一个元素添加click事件时，如果事件是委托到 document 或 body 上，并且委托的元素是默认不可点击的（如 div, span 等），此时 click 事件会失效。</p>
</blockquote>
<h2 id="2-H5与APP混合开发遇到的问题总结"><a href="#2-H5与APP混合开发遇到的问题总结" class="headerlink" title="2.H5与APP混合开发遇到的问题总结"></a>2.H5与APP混合开发遇到的问题总结</h2><h3 id="1-ios中日期显示为NaN"><a href="#1-ios中日期显示为NaN" class="headerlink" title="1.ios中日期显示为NaN"></a>1.ios中日期显示为NaN</h3><p>问题描述</p>
<blockquote>
<p>Date的日期格式，在ios中有兼容性问题，ios的日期会显示成：NaN</p>
</blockquote>
<p>解决方法</p>
<blockquote>
<p>在ios中支持”2018/03/06 12:36:00”，而不支持”2018-03-06 12:36:00”格式，后面一种格式，在ios中显示Nan （Android中都可以显示正常）</p>
</blockquote>
<p>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> time = <span class="string">"2017-03-06 12:36:00"</span>;</div><div class="line">time = time.replace(<span class="regexp">/\-/g</span>, <span class="string">"/"</span>);<span class="comment">//将时间格式的'-'转成'/'形式，兼容iOS</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue学习遇到的问题]]></title>
      <url>/2018/02/26/vue%E5%AD%A6%E4%B9%A0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近在学习vue，遇到了一些问题，在这里记录一下。</p>
<h2 id="vue使用路由后刷新页面回到首页"><a href="#vue使用路由后刷新页面回到首页" class="headerlink" title="vue使用路由后刷新页面回到首页"></a>vue使用路由后刷新页面回到首页</h2><blockquote>
<p>项目需要在页面刷新后回到首页，使用的是这个方法。这个this.$router.push(“/“)里面的”/“可以换为你的任何页面，如”/home”,”/company”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">        <span class="attr">mounted</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.$router.push(<span class="string">'/'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>vue2.x—vue-router如何在router-link标签绑定click点击事件、keyup、change等事件。</p>
</blockquote>
<figure class="highlight plain"><figcaption><span>html></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;router-link to=&apos;/home&apos; @click.native=&apos;jump&apos; &gt;page2&lt;/router-link&gt;</div><div class="line"></div><div class="line">//在事件后面加native就能解决</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[工作总结]]></title>
      <url>/2017/06/08/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="使用jquery修改css中带有-important的样式属性"><a href="#使用jquery修改css中带有-important的样式属性" class="headerlink" title="使用jquery修改css中带有!important的样式属性"></a>使用jquery修改css中带有!important的样式属性</h2><blockquote>
<p>如何使用jquery修改css中带有!important的样式属性？</p>
</blockquote>
<p>外部样式</p>
<figure class="highlight plain"><figcaption><span>html></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div.test&#123;</div><div class="line">  width:100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过$(‘.test’).css(‘width’, ‘100px !important’)或者$(‘.test’).css({‘width’: ‘100px !important’})修改是无效的。</p>
<font color="red">要想修改div.test的width需要用下面的分方式实现</font>

<p>$(“div.test”).css(“cssText”, “width:650px !important;”);<br>要想修改多个属性，可以这么做：<br>$(“div.test”).css(“cssText”, “width:650px !important;overflow:hidden !important”);</p>
<p>好了，就这样了，之前没遇见过这个问题的可以参考一下。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2017/06/01/test/</url>
      <content type="html"><![CDATA[<p>tHub Wikis is a simple way to let others contribute content. Any GitHub user can create and edit pages to use for documentation, examples, support, or anything you wish.<br>Restrict editing to collaborators only<br>Public wikis will still be readable by everyone.<br>Issues<br>GitHub Issues adds lightweight issue tracking tightly integrated with your repository. Add issues to milestones, label issues, and close &amp; reference issues from commit messages.<br>Projects<br>Project boards on GitHub help you organize and prioritize your work. You can create project boards for specific feature work, comprehensive roadmaps, or even release checklists.<br>Merge button<br>When merging pull requests, you can allow any combination of merge commits, squashing, or rebasing. At least one option must be enabled.</p>
<p>Allow merge commits<br>Add all commits from the head branch to the base branch with a merge commit.<br>Allow squash merging<br>Combine all commits from the head branch into a single commit in the base branch.<br>Allow rebase merging<br>Add all commits from the head branch onto the base branch individually.<br>Temporary interaction limits<br>Temporarily restrict which users can interact with your repository (comment, open issues, or create pull requests) for a 24-hour period. This may be used to force a “cool-down” period during heated discussions.</p>
<p>Limit to existing users<br>Users that have recently created their account will be unable to interact with the repository.<br>Limit to prior contributors<br>Users that have not previously committed to the repository’s master branch will be unable to interact with the repository.<br>Limit to repository collaborators<br>Users that have not been granted push access will be unable to interact with the repository.<br>GitHub Pages<br>Your site is ready to be published at <a href="https://wfj0527.github.io/krystal.github.io/" target="_blank" rel="external">https://wfj0527.github.io/krystal.github.io/</a>.<br>GitHub Pages is designed to host your personal, organization, or project pages from a GitHub repository.</p>
<p>Source<br>Your GitHub Pages site is currently being built from the master branch. Learn more.<br> master branch   Save</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[面试总结]]></title>
      <url>/2017/04/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="你如何理解HTML结构的语意化"><a href="#你如何理解HTML结构的语意化" class="headerlink" title="你如何理解HTML结构的语意化?"></a>你如何理解HTML结构的语意化?</h2><ul>
<li>1、去掉或样式丢失的时候能让页面呈现清晰的结构。</li>
<li>2、屏幕阅读器（如果访客有视障）会完全根据你的标记来”读”你的网页。</li>
<li>3、PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。</li>
<li>4、搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。</li>
<li>5、你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记，而只注重语义标记。</li>
<li>6、便于团队开发和维护。</li>
</ul>
<h2 id="我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？"><a href="#我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？" class="headerlink" title="我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？"></a>我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？</h2><p>CSS的引入方式最常用的有三种：</p>
<ul>
<li>第一：在head部分加入<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;my.css&quot;/&gt;</code>, 引入外部的CSS文件。</li>
<li><p>第二：在head部分加入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"> </span></div><div class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>;<span class="attribute">border</span>:<span class="number">1px</span> red solid;&#125; </div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>第三:直接在页面的标签里加<code>&lt;div style=&quot;border:1px red solid;&quot;&gt;</code></p>
</li>
</ul>
<h2 id="行内元素有哪些？块级元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？"></a>行内元素有哪些？块级元素有哪些？</h2><ul>
<li>行内元素: a b span em img input select strong</li>
<li>块级元素：div ul li dl dt h1 h2 h3 p</li>
</ul>
<h2 id="前端网页由哪三层构成，分别是什么？作用是什么？"><a href="#前端网页由哪三层构成，分别是什么？作用是什么？" class="headerlink" title="前端网页由哪三层构成，分别是什么？作用是什么？"></a>前端网页由哪三层构成，分别是什么？作用是什么？</h2><p>网页分成三个层次，即：结构层、表示层、行为层。</p>
<ul>
<li>1、网页的结构层（structurallayer）由HTML 或XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：”这是一个文本段。”</li>
<li>2、网页的表示层（presentationlayer）由CSS 负责创建。CSS对”如何显示有关内容”的问题做出了回答。</li>
<li>3、网页的行为层（behaviorlayer）负责回答”内容应该如何对事件做出反应”这一问题。这是Javascript 语言和DOM 主宰的领域</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊跨域]]></title>
      <url>/2017/04/09/%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h2 id="那些年，那些跨域"><a href="#那些年，那些跨域" class="headerlink" title="那些年，那些跨域"></a>那些年，那些跨域</h2><p>浏览器在请求不同域的资源时，会因为同源策略的影响请求不成功，这就是通常被提到的“跨域问题”。作为前端开发，解决跨域问题应该是一个被熟练掌握的技能。而随着技术不断的更迭，针对跨域问题的解决也衍生出了多种解决方案。我们通常会根据项目的不同需要，而采取不同的方式。这篇文章，将详细总结跨域问题的相关知识点，以便在遇到相同问题的时候，能有一个清晰的解决思路。</p>
<h2 id="跨域问题产生的背景"><a href="#跨域问题产生的背景" class="headerlink" title="跨域问题产生的背景"></a>跨域问题产生的背景</h2><p>早期为了防止CSRF（跨域请求伪造）的攻击，浏览器引入了同源策略(SOP)来提高安全性。</p>
<blockquote>
<p>CSRF（Cross-site request forgery），跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
</blockquote>
<p>而所谓”同源策略”，即同域名(domain或ip)、同端口、同协议的才能互相获取资源，而不能访问其他域的资源。在同源策略影响下，一个域名A的网页可以获取域名B下的脚本,css,图片等，但是不能发送Ajax请求，也不能操作Cookie、LocalStorage等数据。同源策略的存在，一方面提高了网站的安全性，但同时在面对前后端分离、模拟测试等场景时，也带来了一些麻烦，从而不得不寻求一些方法来突破限制，获取资源。</p>
<h2 id="JS跨域"><a href="#JS跨域" class="headerlink" title="JS跨域"></a>JS跨域</h2><p>这里所说的JS跨域，指的是在处理跨域请求的过程中，技术面会偏浏览器端较多一些，一般是利用浏览器的一些特性进行hack处理，从而避开同源策略的限制。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>由于同源策略不会阻止动态脚本的插入到文档中去，所以催生出了一种很常用的跨域方式： JSONP(JSON with Padding)。</p>
<p>原理说起来也很简单：</p>
<p>假设，我们源页面是在a.com,想要获取b.com的数据，我们可以动态插入来源于b.com的脚本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">script.type = <span class="string">'text/javascript'</span>;</div><div class="line">script.src = <span class="string">'http://www.b.com/getdata?callback=demo'</span>;</div></pre></td></tr></table></figure>
<p>这里，我们利用动态脚本的src属性，变相地发送了一个<a href="http://www.b.com/getdata?callback=demo的GET" target="_blank" rel="external">http://www.b.com/getdata?callback=demo的GET</a>  请求。这时候，b.com页面接受到这个请求时，如果没有JSONP,会正常返回json的数据结果，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">msg</span>: <span class="string">'helloworld'</span> &#125;</div></pre></td></tr></table></figure>
<p>而利用JSONP,服务端会接受这个callback参数，然后用这个参数值包装要返回的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo(&#123;<span class="attr">msg</span>: <span class="string">'helloworld'</span>&#125;);</div></pre></td></tr></table></figure>
<p>这时候，如果a.com的页面上正好有一个demo的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当远程数据一返回的时候，随着动态脚本的执行，这个demo函数就会被执行。</p>
<p>到这里，你应该能明白这个技术为什么叫JSONP了吧？就是因为使用这种技术服务器会接受回调函数名作为请求参数，并将JSON数据填充进回调函数中去。</p>
<p>不过一般在实际开发的时候，我们一般会利用jQuery对JSONP的支持，而避免手写很多代码。从1.2版本开始，jQuery中加入了对JSONP的支持，可以使用$.getJSON方法来请求跨域数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//callback后面的?会由jQuery自动生成方法名</span></div><div class="line">$.getJSON(<span class="string">'http://www.b.com/getdata?callback=?'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还有一种更加常用的方法是，利用$.ajax方法，只要指定dataType为jsonp即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">  <span class="attr">url</span>: <span class="string">'http://www.b.com/getdata?callback=?'</span>, <span class="comment">//不指定回调名，可省略callback参数，会由jQuery自动生成</span></div><div class="line">  dataType: <span class="string">'jsonp'</span>,</div><div class="line">  <span class="attr">jsonpCallback</span>: <span class="string">'demo'</span>, <span class="comment">//可省略</span></div><div class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data.msg);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>虽然JSONP在跨域ajax请求方面有很强的能力，但是它也有一些缺陷。首先，它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。</p>
<p>由于JSONP对于老浏览器兼容性方面比较良好，因此，对于那些对IE8以下仍然需要支持的网站来说，仍然被广泛应用。不过，针对高级浏览器，建议还是使用接下来会介绍的CORS方法。</p>
<h2 id="CORS解决跨域"><a href="#CORS解决跨域" class="headerlink" title="CORS解决跨域"></a>CORS解决跨域</h2>]]></content>
      
        
    </entry>
    
  
  
</search>
